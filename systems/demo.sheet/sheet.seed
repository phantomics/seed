(in-package #:seed)

(seed :demo.sheet
      :bindings (:package package :system system :portal-name portal-name)
      :branches (:view
                 (lambda (input)
                   (-<> (uic-set ((:type :group :linear :workspace :even)
                                  (:members :column :column))
                                 ;; (uic ((:type :form :text) (:access :main)
                                 ;;       (:controls (:header :save)
                                 ;;                  (:footer :save))))
                                 ;; (uic ((:type :form :tree) (:access :code)
                                 ;;       (:controls (:header :save)
                                 ;;                  (:footer :save))))
                                 ;; (uic ((:type :form :vector) (:access :code) ;; what's this?
                                 ;;       (:controls (:header :save)
                                 ;;                  (:footer :save))))
                                 ;; (uic ((:type :form :vector) (:access :graph)
                                 ;;       (:controls (:header :save)
                                 ;;                  (:footer :save))))
                                 (uic ((:type :form :elem) (:access :graph)
                                       (:controls (:header :save)
                                                  (:footer :save))))
                                 ;; (uic ((:type :form :elem) (:access :form)
                                 ;;       (:controls (:header :save)
                                 ;;                  (:footer :save))))
                                 ;; (uic ((:type :form :elem) (:access :table)
                                 ;;       (:controls (:header :submit)
                                 ;;                  (:footer :submit))))
                                 (uic ((:type :form :cells) (:access :cells)
                                       (:controls (:header :save :toggle-baseline)
                                                  (:footer :save))))
                                 )
                     (in-system-context <> package)))
                 :main
                 (lambda (input)
                   (if input (let ((input (apply #'concatenate 'string
                                                 (loop :for i :in input :append (list i '(#\Newline))))))
                               (setf (from-system-file package "sheet.lisp" :main :as-string t)
                                     (text-wrap input :syntax :progn))
                               ;; (instantiate-priority-macro-reader (asdf:load-system package))
                               (load-seed-system package)
                               (list :text (text-wrap (from-system-file package "sheet.lisp"
                                                                        :main :as-string t)
                                                      :unwrap t :syntax :progn)))
                       (list :text (text-wrap (from-system-file package "sheet.lisp"
                                                                :main :as-string t)
                                              :unwrap t :syntax :progn :trailing-newlines 2))))
                 :code
                 (lambda (input)
                   (seed.generate::form-as-vectors
                    (seed.generate::form-span (encode '((+ 1 (* 3 4)) (* 8 5))))))
                 :form
                 (lambda (input)
                   (when (third input)
                     ;; only process input if fields apart form system/branch are present
                     (let ((original (from-system-file package "sheet.lisp" :form)))
                       (meta-revise (second (third original)) input)
                       (setf (from-system-file package "sheet.lisp" :form) original)))
                   (let ((out (make-string-output-stream)))
                     (spinneret:interpret-html-tree
                      ;; (render-fieldset (second (third (from-system-file package "sheet.lisp" :form))))
                      (htrender (second (third (from-system-file package "sheet.lisp" :form)))
                                :params (list :system package :branch :form))
                      :stream out)
                     (get-output-stream-string out)))
                 :table
                 (let ((original (from-system-file package "sheet.lisp" :table)))
                   (lambda (input)
                     (print (list :in input))
                     (when (third input)
                       ;; only process input if fields apart form system/branch are present
                       (meta-revise (second (third original)) input)
                       ;; (setf (from-system-file package "sheet.lisp" :table) original)
                       (let ((val-key :t) (unit-key) (count 0)
                             (vout (make-string-output-stream))
                             (uout (make-string-output-stream)))
                         (format vout "#~%") (format uout "~%#~%")
                         (loop :while val-key :for ix :from 0
                               :do (setf val-key  (intern (format nil "V-~a" ix) "KEYWORD")
                                         unit-key (intern (format nil "U-~a" ix) "KEYWORD"))
                                   (print (list :vk val-key unit-key))
                                   (if (assoc val-key input)
                                       (progn (when (= 5 count)
                                                (setf count 0)
                                                (format vout "~%#~%"))
                                              (format vout "  ~a  |"
                                                      (rest (assoc val-key  input)))
                                              (format uout " ~a |"
                                                      (rest (assoc unit-key input)))
                                              (incf count))
                                       (setf val-key nil)))
                         ;; (print (list :st (concatenate 'string
                         ;;                               (get-output-stream-string vout)
                         ;;                               (get-output-stream-string uout))))
                         )
                       )
                     (let ((out (make-string-output-stream)))
                       (spinneret:interpret-html-tree
                        (htrender (second (third original))
                                  :params (list :system package :branch :table))
                        :stream out)
                       (get-output-stream-string out))))
                 ;; :graphone
                 ;; (lambda (input)
                 ;;   (let ((data '(build-directed-graph2
                 ;;                 (((:title "First node."))
                 ;;                  (((:title "Link to second node."))
                 ;;                   1))
                 ;;                 (((:title "Second node."))
                 ;;                  (((:title "Link to third node."))
                 ;;                   2))
                 ;;                 (((:title "Third node."))
                 ;;                  (((:title "Link to first node."))
                 ;;                   0))
                 ;;                 )))
                 ;;     (if input (let ((index (rest (assoc "index" input :test #'string=))))
                 ;;                 (of-graph-spec data index))
                 ;;         (of-graph-spec data))))
                 :graph
                 (let* ((data (seed.generate::build-directed-graph2
                                 (((:title "First node."))
                                  (((:title "Link to second node."))
                                   1))
                                 (((:title "Second node."))
                                  (((:title "Link to third node."))
                                   2))
                                 (((:title "Third node."))
                                  (((:title "Link to first node."))
                                   0))
                                 ))
                        (formatted (seed.generate::dgraph-interface data))
                        (el-width) (el-height))
                   ;; (seed.generate::dgraph-interface data formatted :path '(0 0) :to-open t)
                   ;; (seed.generate::dgraph-interface data formatted :path '(1 0) :to-open t)
                   (lambda (input)
                     ;; (print (list :in input))
                     (when (and input (assoc "width" input :test #'string=))
                       (setf el-width (rest (assoc "width" input :test #'string=))
                             el-height (rest (assoc "height" input :test #'string=))))
                     (when (and input (assoc "path" input :test #'string=))
                       (let ((inst (make-string-input-stream
                                    (rest (assoc "path" input :test #'string=)))))
                         (seed.generate::dgraph-interface
                          data formatted :path (loop :for c := (read inst nil)
                                                     :while c :collect c)
                          :to-open t)
                         (close inst)))
                     (when (and input (assoc "closePath" input :test #'string=))
                       (let ((inst (make-string-input-stream
                                    (rest (assoc "closePath" input :test #'string=)))))
                         (seed.generate::dgraph-interface
                          data formatted :path (loop :for c := (read inst nil)
                                                     :while c :collect c)
                          :to-open nil)
                         (close inst)))
                     ;; the *output-stream* is created in the seed package - best elsewhere?
                     (when (assoc :system input)
                       (setf *output-stream* (make-string-output-stream))
                       (eval `(cl-who:with-html-output (*output-stream*)
                                (:svg :class "svg-visualizer"
                                      :width ,el-width :height ,el-height
                                      ,@(seed.generate::svrender-graph
                                         formatted
                                         :expand-control-format
                                         (lambda (form)
                                           (setf (rest form)
                                                 (append (list :|x-on:click|
                                                               '(psl
                                                                 (progn
                                                                   (chain console
                                                                          (log "click"
                                                                               (chain $el (get-attribute
                                                                                           "path"))))
                                                                   (fetch-contact
                                                                    "DEMO.SHEET" "GRAPH"
                                                                    (create path
                                                                            (chain $el (get-attribute
                                                                                        "path")))
                                                                    (lambda (data)
                                                                      (chain htmx
                                                                             (trigger "#branch-graph"
                                                                                      "reload"))
                                                                      )))))
                                                         (rest form)))
                                           form)
                                         :contract-control-format
                                         (lambda (form)
                                           (setf (rest form)
                                                 (append (list :|x-on:click|
                                                               '(psl
                                                                 (progn
                                                                   (chain console
                                                                          (log "click"
                                                                               (chain $el (get-attribute
                                                                                           "path"))))
                                                                   (fetch-contact
                                                                    "DEMO.SHEET" "GRAPH"
                                                                    (create close-path
                                                                            (chain $el (get-attribute
                                                                                        "path")))
                                                                    (lambda (data)
                                                                      (chain htmx
                                                                             (trigger "#branch-graph"
                                                                                      "reload"))
                                                                      )))))
                                                         (rest form)))
                                           form)
                                         ))))
                       (let ((output (get-output-stream-string *output-stream*)))
                         (close *output-stream*)
                         output))))
                 :cells
                 (let ((display-baseline))
                   (lambda (input)
                     (if input (if (and (listp input) (listp (first input))
                                        (stringp (caar input)))
                                   (cond ((string= "toggleBaseline" (caar input))
                                          (setf display-baseline (not display-baseline))))
                                   (let ((original (from-system-file package "sheet.lisp" :cells)))
                                     (setf (of-array-spec :initial-contents (defvar-value original))
                                           `(quote ,(loop :for row :in input
                                                          :collect (loop :for cell :in row
                                                                         :collect (parse-number:parse-number
                                                                                   cell))))
                                           (from-system-file package "sheet.lisp" :cells) original)
                                     ;; (instantiate-priority-macro-reader (asdf:load-system package))
                                     (load-seed-system package)))
                         (if display-baseline (encode (symbol-value (intern "*CELL-MATRIX*"
                                                                            (string package))))
                             (list :ty :ar :ct
                                   (second (of-array-spec :initial-contents
                                                          (defvar-value
                                                              (from-system-file
                                                               package "sheet.lisp" :cells)))))))))))

